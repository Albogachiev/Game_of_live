{"ast":null,"code":"var _jsxFileName = \"/home/smart/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/my_Project/test_task/my-app/src/components/Main.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport '../index.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst arrGenerator = () => {\n  const numRows = 25;\n  const numCols = 25;\n  return Array.from({\n    length: numRows\n  }, () => Array(numCols).fill(false));\n};\nexport const GameOfLife = () => {\n  _s();\n  const [grid, setGrid] = useState(arrGenerator);\n  const [run, setRun] = useState(false);\n  const searching = ({\n    grid,\n    row,\n    col\n  }) => {\n    const arrIndex = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n    let elem = 0;\n    arrIndex.forEach(([rowIndex, colIndex]) => {\n      const newRow = row + rowIndex;\n      const newCol = col + colIndex;\n      if (newRow < 0 || newRow > 24 || newCol < 0 || newCol > 24) return;\n      elem += grid[newRow][newCol] ? 1 : 0;\n    });\n    return elem;\n  };\n  const nextGeneration = arr => {\n    arr.map((row, rowIndex) => {\n      row.map((item, colIndex) => {\n        const result = searching({\n          grid: arr,\n          row: rowIndex,\n          col: colIndex\n        });\n        if (result >= 2 || result <= 3) {\n          item = false;\n        }\n      });\n    });\n    return arr;\n  };\n  const toggleCell = (row, col) => {\n    const newGrid = [...grid];\n    newGrid[row][col] = !newGrid[row][col];\n    setGrid(newGrid);\n  };\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      setGrid(prev => nextGeneration(prev));\n    }, 1000);\n    return () => clearTimeout(timeout);\n  }, [run]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid\",\n      children: grid === null || grid === void 0 ? void 0 : grid.map((row, rowIndex) => row === null || row === void 0 ? void 0 : row.map((item, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: item ? {\n          backgroundColor: 'black'\n        } : {\n          backgroundColor: 'white'\n        },\n        onClick: () => toggleCell(rowIndex, colIndex),\n        className: \"cell\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 73,\n        columnNumber: 13\n      }, this)))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => setRun(!run),\n      children: run ? 'Stop' : 'Start'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 69,\n    columnNumber: 5\n  }, this);\n};\n\n// import React, { useState, useEffect } from 'react';\n\n// // Функция для создания нового пустого поля\n// const createEmptyGrid = () => {\n//   const numRows = 25;\n//   const numCols = 25;\n//   return Array.from({ length: numRows }, () => Array(numCols).fill(false));\n// };\n\n// // Функция для подсчета живых соседей\n// const countNeighbors = (grid: Array<number[]>, row: number, col: number) => {\n//   const directions = [\n// [-1, -1],\n// [-1, 0],\n// [-1, 1],\n// [0, -1],\n// [0, 1],\n// [1, -1],\n// [1, 0],\n// [1, 1],\n//   ];\n//   const arr = [\n//     [1, 2, 3, 4, 5],\n//     [6, 7, 8, 9, 10],\n//     [11, 12, 13, 14, 15],\n//   ];\n//   const row2 = 1;\n//   const col2 = 3;\n//   console.log(arr[row2][col2], '<<<');\n//   let neighbors = 0;\n//   directions.forEach(([dx, dy]) => {\n//     const newRow = row + dx;\n//     const newCol = col + dy;\n//     if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {\n//       neighbors += grid[newRow][newCol] ? 1 : 0;\n//     }\n//   });\n\n//   return neighbors;\n// };\n\n// // Функция для вычисления следующего состояния доски\n// const nextGeneration = (grid: Array<number[]>) => {\n//   const newGrid = grid.map((row, rowIndex) =>\n//     row.map((cell, colIndex) => {\n//       const neighbors = countNeighbors(grid, rowIndex, colIndex);\n//       if (cell && (neighbors === 2 || neighbors === 3)) {\n//         return true;\n//       }\n//       if (!cell && neighbors === 3) {\n//         return true;\n//       }\n//       return false;\n//     }),\n//   );\n//   return newGrid;\n// };\n\n// export const GameOfLife = () => {\n//   const [grid, setGrid] = useState(createEmptyGrid);\n//   const [running, setRunning] = useState(false);\n\n//   // Обновление сетки каждую секунду, если игра запущена\n//   useEffect(() => {\n//     if (!running) return;\n\n//     const interval = setInterval(() => {\n//       setGrid((prevGrid) => nextGeneration(prevGrid));\n//     }, 4000);\n\n//     return () => clearInterval(interval); // Останавливаем обновление при размонтировании компонента\n//   }, [running]);\n\n//   // Функция для изменения состояния клетки при клике\n//   const toggleCell = (row: number, col: number) => {\n//     const newGrid = [...grid];\n//     newGrid[row][col] = !newGrid[row][col];\n//     setGrid(newGrid);\n//   };\n\n//   return (\n//     <div>\n//       <h1>Game of Life</h1>\n//       <div style={{ display: 'grid', gridTemplateColumns: `repeat(${grid[0].length}, 20px)` }}>\n//         {grid.map((row, rowIndex) =>\n//           row.map((cell, colIndex) => (\n//             <div\n//               key={`${rowIndex}-${colIndex}`}\n//               onClick={() => toggleCell(rowIndex, colIndex)}\n//               style={{\n//                 width: 20,\n//                 height: 20,\n//                 backgroundColor: cell ? 'black' : 'white',\n//                 border: '1px solid gray',\n//                 cursor: 'pointer',\n//               }}\n//             />\n//           )),\n//         )}\n//       </div>\n//       <div style={{ marginTop: 20 }}>\n//         <button onClick={() => setRunning(!running)}>{running ? 'Stop' : 'Start'}</button>\n//         <button onClick={() => setGrid(createEmptyGrid())}>Clear</button>\n//         <button onClick={() => setGrid(createEmptyGrid())}>Randomize</button>\n//       </div>\n//     </div>\n//   );\n// };\n_s(GameOfLife, \"bKOO9k2y4wPuvdRN2sTLqRx/s60=\");\n_c = GameOfLife;\nvar _c;\n$RefreshReg$(_c, \"GameOfLife\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","arrGenerator","numRows","numCols","Array","from","length","fill","GameOfLife","_s","grid","setGrid","run","setRun","searching","row","col","arrIndex","elem","forEach","rowIndex","colIndex","newRow","newCol","nextGeneration","arr","map","item","result","toggleCell","newGrid","timeout","setTimeout","prev","clearTimeout","className","children","style","backgroundColor","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/smart/Рабочий стол/my_Project/test_task/my-app/src/components/Main.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport '../index.css';\n\nconst arrGenerator = () => {\n  const numRows = 25;\n  const numCols = 25;\n  return Array.from({ length: numRows }, () => Array(numCols).fill(false));\n};\n\nexport const GameOfLife = () => {\n  const [grid, setGrid] = useState<Array<Array<boolean>>>(arrGenerator);\n  const [run, setRun] = useState(false);\n\n  const searching = ({\n    grid,\n    row,\n    col,\n  }: {\n    grid: Array<Array<boolean>>;\n    row: number;\n    col: number;\n  }) => {\n    const arrIndex = [\n      [-1, -1],\n      [-1, 0],\n      [-1, 1],\n      [0, -1],\n      [0, 1],\n      [1, -1],\n      [1, 0],\n      [1, 1],\n    ];\n    let elem = 0;\n    arrIndex.forEach(([rowIndex, colIndex]) => {\n      const newRow = row + rowIndex;\n      const newCol = col + colIndex;\n      if (newRow < 0 || newRow > 24 || newCol < 0 || newCol > 24) return;\n      elem += grid[newRow][newCol] ? 1 : 0;\n    });\n    return elem;\n  };\n\n  const nextGeneration = (arr: Array<Array<boolean>>) => {\n    arr.map((row, rowIndex) => {\n      row.map((item, colIndex) => {\n        const result = searching({ grid: arr, row: rowIndex, col: colIndex });\n        if (result >= 2 || result <= 3) {\n          item = false;\n        }\n      });\n    });\n    return arr;\n  };\n\n  const toggleCell = (row: number, col: number) => {\n    const newGrid = [...grid];\n    newGrid[row][col] = !newGrid[row][col];\n    setGrid(newGrid);\n  };\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      setGrid((prev) => nextGeneration(prev));\n    }, 1000);\n    return () => clearTimeout(timeout);\n  }, [run]);\n\n  return (\n    <div className='container'>\n      <div className='grid'>\n        {grid?.map((row, rowIndex) =>\n          row?.map((item, colIndex) => (\n            <div\n              style={item ? { backgroundColor: 'black' } : { backgroundColor: 'white' }}\n              onClick={() => toggleCell(rowIndex, colIndex)}\n              className='cell'\n            ></div>\n          )),\n        )}\n      </div>\n      <button onClick={() => setRun(!run)}>{run ? 'Stop' : 'Start'}</button>\n    </div>\n  );\n};\n\n// import React, { useState, useEffect } from 'react';\n\n// // Функция для создания нового пустого поля\n// const createEmptyGrid = () => {\n//   const numRows = 25;\n//   const numCols = 25;\n//   return Array.from({ length: numRows }, () => Array(numCols).fill(false));\n// };\n\n// // Функция для подсчета живых соседей\n// const countNeighbors = (grid: Array<number[]>, row: number, col: number) => {\n//   const directions = [\n// [-1, -1],\n// [-1, 0],\n// [-1, 1],\n// [0, -1],\n// [0, 1],\n// [1, -1],\n// [1, 0],\n// [1, 1],\n//   ];\n//   const arr = [\n//     [1, 2, 3, 4, 5],\n//     [6, 7, 8, 9, 10],\n//     [11, 12, 13, 14, 15],\n//   ];\n//   const row2 = 1;\n//   const col2 = 3;\n//   console.log(arr[row2][col2], '<<<');\n//   let neighbors = 0;\n//   directions.forEach(([dx, dy]) => {\n//     const newRow = row + dx;\n//     const newCol = col + dy;\n//     if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {\n//       neighbors += grid[newRow][newCol] ? 1 : 0;\n//     }\n//   });\n\n//   return neighbors;\n// };\n\n// // Функция для вычисления следующего состояния доски\n// const nextGeneration = (grid: Array<number[]>) => {\n//   const newGrid = grid.map((row, rowIndex) =>\n//     row.map((cell, colIndex) => {\n//       const neighbors = countNeighbors(grid, rowIndex, colIndex);\n//       if (cell && (neighbors === 2 || neighbors === 3)) {\n//         return true;\n//       }\n//       if (!cell && neighbors === 3) {\n//         return true;\n//       }\n//       return false;\n//     }),\n//   );\n//   return newGrid;\n// };\n\n// export const GameOfLife = () => {\n//   const [grid, setGrid] = useState(createEmptyGrid);\n//   const [running, setRunning] = useState(false);\n\n//   // Обновление сетки каждую секунду, если игра запущена\n//   useEffect(() => {\n//     if (!running) return;\n\n//     const interval = setInterval(() => {\n//       setGrid((prevGrid) => nextGeneration(prevGrid));\n//     }, 4000);\n\n//     return () => clearInterval(interval); // Останавливаем обновление при размонтировании компонента\n//   }, [running]);\n\n//   // Функция для изменения состояния клетки при клике\n//   const toggleCell = (row: number, col: number) => {\n//     const newGrid = [...grid];\n//     newGrid[row][col] = !newGrid[row][col];\n//     setGrid(newGrid);\n//   };\n\n//   return (\n//     <div>\n//       <h1>Game of Life</h1>\n//       <div style={{ display: 'grid', gridTemplateColumns: `repeat(${grid[0].length}, 20px)` }}>\n//         {grid.map((row, rowIndex) =>\n//           row.map((cell, colIndex) => (\n//             <div\n//               key={`${rowIndex}-${colIndex}`}\n//               onClick={() => toggleCell(rowIndex, colIndex)}\n//               style={{\n//                 width: 20,\n//                 height: 20,\n//                 backgroundColor: cell ? 'black' : 'white',\n//                 border: '1px solid gray',\n//                 cursor: 'pointer',\n//               }}\n//             />\n//           )),\n//         )}\n//       </div>\n//       <div style={{ marginTop: 20 }}>\n//         <button onClick={() => setRunning(!running)}>{running ? 'Stop' : 'Start'}</button>\n//         <button onClick={() => setGrid(createEmptyGrid())}>Clear</button>\n//         <button onClick={() => setGrid(createEmptyGrid())}>Randomize</button>\n//       </div>\n//     </div>\n//   );\n// };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}